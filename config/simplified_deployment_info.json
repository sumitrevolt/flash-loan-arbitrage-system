{
  "contract_address": "0x7dB59723064aaD15b90042b9205F60A6A7029ABF",
  "transaction_hash": "0xf2f87a63d090dfaee0a14b13535b53caf0e7ed536508d466c3704eab52b10e05",
  "block_number": 72865825,
  "gas_used": 1013807,
  "constructor_args": [
    "0xa97684ead0e402dC232d5A977953DF7ECBaB3CDb"
  ],
  "compiler_version": "0.8.10",
  "optimization": true,
  "optimization_runs": 200,
  "contract_source": "\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IPoolAddressesProvider {\n    function getPool() external view returns (address);\n}\n\ninterface IPool {\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n}\n\ninterface IFlashLoanReceiver {\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external returns (bool);\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n\ncontract FlashLoanArbitrageFixed is IFlashLoanReceiver, Ownable, ReentrancyGuard {\n    IPoolAddressesProvider public immutable addressesProvider;\n    IPool public immutable pool;\n    \n    // Events\n    event FlashLoanExecuted(address indexed asset, uint256 amount, uint256 premium);\n    event ProfitWithdrawn(address indexed token, uint256 amount);\n    \n    // Errors\n    error UnauthorizedFlashLoan();\n    error InsufficientBalance();\n    error TransferFailed();\n    \n    constructor(address _addressesProvider) {\n        addressesProvider = IPoolAddressesProvider(_addressesProvider);\n        pool = IPool(addressesProvider.getPool());\n    }\n    \n    /**\n     * @dev Execute flash loan operation\n     */\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external override returns (bool) {\n        // Verify the caller is the AAVE pool\n        require(msg.sender == address(pool), \"Caller must be AAVE pool\");\n        require(initiator == address(this), \"Initiator must be this contract\");\n        \n        // Perform arbitrage logic here\n        // For now, just ensure we have enough balance to repay\n        for (uint256 i = 0; i < assets.length; i++) {\n            uint256 totalRepayment = amounts[i] + premiums[i];\n            \n            // Check if we have enough balance to repay\n            IERC20 asset = IERC20(assets[i]);\n            require(asset.balanceOf(address(this)) >= totalRepayment, \"Insufficient balance for repayment\");\n            \n            // Approve the pool to pull the funds\n            asset.approve(address(pool), totalRepayment);\n        }\n        \n        emit FlashLoanExecuted(assets[0], amounts[0], premiums[0]);\n        return true;\n    }\n    \n    /**\n     * @dev Execute flash loan\n     */\n    function executeFlashLoan(\n        address asset,\n        uint256 amount\n    ) external onlyOwner nonReentrant {\n        address[] memory assets = new address[](1);\n        uint256[] memory amounts = new uint256[](1);\n        uint256[] memory modes = new uint256[](1);\n        \n        assets[0] = asset;\n        amounts[0] = amount;\n        modes[0] = 0; // no debt\n        \n        pool.flashLoan(\n            address(this),\n            assets,\n            amounts,\n            modes,\n            address(this),\n            \"\",\n            0\n        );\n    }\n    \n    /**\n     * @dev Withdraw profits\n     */\n    function withdrawProfit(address token, uint256 amount) external onlyOwner {\n        IERC20 tokenContract = IERC20(token);\n        require(tokenContract.balanceOf(address(this)) >= amount, \"Insufficient balance\");\n        \n        bool success = tokenContract.transfer(owner(), amount);\n        require(success, \"Transfer failed\");\n        \n        emit ProfitWithdrawn(token, amount);\n    }\n    \n    /**\n     * @dev Emergency withdraw all tokens\n     */\n    function emergencyWithdraw(address token) external onlyOwner {\n        IERC20 tokenContract = IERC20(token);\n        uint256 balance = tokenContract.balanceOf(address(this));\n        if (balance > 0) {\n            bool success = tokenContract.transfer(owner(), balance);\n            require(success, \"Emergency withdraw failed\");\n        }\n    }\n    \n    /**\n     * @dev Get contract balance for a token\n     */\n    function getBalance(address token) external view returns (uint256) {\n        return IERC20(token).balanceOf(address(this));\n    }\n    \n    // Receive function to accept ETH\n    receive() external payable {}\n}\n"
}